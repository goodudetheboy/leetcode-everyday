Find a Corresponding Node of a Binary Tree in a Clone of That Tree (Medium) https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/
Initial thought: Easy level question.

Solution: Optimal.

What to learn: Despite this, the Solution to this contains every single approaches to finding value inside a unique binary tree. Very useful if I want to go over this.

--------------------------
Find Peak Element (Medium) https://leetcode.com/problems/find-peak-element/
Initial thought: Simple traversal from start to end until you find a first decreasing. But this slow. So I switched to binary search. If left < right just move mid to left. Done.

Solution: Optimal.

What to learn: Peak finding. Very interesting stuff, from what I read in the comments.

--------------------------
Remove Duplicates from Sorted List II (Medium) https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/
Initial thought: Repeat from previous, since I wasn't able to do it then. Just traverse through and drop head when you see shit.

Solution: Optimal time, semi-optimal. There's a sentinel head solution that use O(1) space. Very neat.

What to learn: Sentinel head.

--------------------------
Interval List Intersections (Medium) https://leetcode.com/problems/interval-list-intersections/
Initial thought: Damn I'm thinking way too complicated again. I know to use the two pointers, but ik shit went AWOL when my algo implementation is getting fucked up. Resorted to using Solution...

Solution: Just check two at a time. Find max and min of two endpoints, if two new endpoints are valid, then add. Move pointer based on end endpoints.

What to learn: Think less complicated.
